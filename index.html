<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Garlic Orbit Shooter</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body{
      background: radial-gradient(1200px 800px at 50% 20%, #182a66 0%, #070a12 55%, #02030a 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      overscroll-behavior: none;
    }

    /* Layout wrapper: fullscreen on phone, centered panel on desktop */
    .stage{
      position: relative;
      width: 100vw;
      height: 100vh;
      display: grid;
      place-items: center;
      padding: 0;
    }

    .frame{
      position: relative;
      width: min(980px, 100vw);
      height: min(660px, 100vh);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.12);
      box-shadow: 0 18px 70px rgba(0,0,0,0.55);
      overflow: hidden;
    }

    /* Phone: full screen vertical */
    @media (max-width: 720px), (pointer: coarse) {
      .frame{
        width: 100vw;
        height: 100vh;
        border-radius: 0;
        border: none;
        box-shadow: none;
      }
    }

    canvas{
      width: 100%;
      height: 100%;
      display: block;
      background: rgba(0,0,0,0.18);
      touch-action: none;
    }

    /* Top bar */
    .topbar{
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
    }
    .pill{
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      font-size: 14px;
      color: rgba(255,255,255,0.92);
      flex-wrap: wrap;
    }
    .pill strong{ font-weight: 800; }
    .btn{
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.92);
      border-radius: 999px;
      padding: 8px 12px;
      font: 700 13px system-ui, sans-serif;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: rgba(80,255,150,0.18);
      border-color: rgba(80,255,150,0.28);
    }
    .btn.danger{
      background: rgba(255,70,70,0.14);
      border-color: rgba(255,70,70,0.22);
    }

    /* Menu overlay (DOM) */
    .overlay{
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .overlay.show{ display: flex; }

    .panel{
      width: min(560px, 96vw);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(10,12,22,0.72);
      box-shadow: 0 22px 90px rgba(0,0,0,0.65);
      padding: 18px;
    }
    .title{
      font: 900 34px system-ui, sans-serif;
      margin: 4px 0 8px 0;
      letter-spacing: 0.5px;
      color: rgba(255,255,255,0.96);
      text-align: center;
    }
    .sub{
      text-align: center;
      color: rgba(255,255,255,0.78);
      font: 600 14px system-ui, sans-serif;
      margin-bottom: 14px;
      line-height: 1.35;
    }
    .grid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin: 12px 0;
    }
    .card{
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
      font-size: 14px;
    }
    .card .k{ opacity: 0.75; font-weight: 700; font-size: 12px; }
    .card .v{ font: 900 22px system-ui, sans-serif; margin-top: 4px; }

    .row{
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    .field{
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      border-radius: 14px;
      padding: 10px 12px;
      margin-top: 10px;
    }
    .field label{
      font: 800 12px system-ui, sans-serif;
      opacity: 0.8;
    }
    .field input{
      width: 220px;
      max-width: 55vw;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      font: 700 14px system-ui, sans-serif;
      outline: none;
    }

    .tabs{
      display: flex;
      gap: 8px;
      justify-content: center;
      margin: 12px 0 6px;
    }

    .tab{
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.85);
      border-radius: 999px;
      padding: 8px 12px;
      font: 800 12px system-ui, sans-serif;
      cursor: pointer;
    }
    .tab.active{
      background: rgba(120,160,255,0.16);
      border-color: rgba(120,160,255,0.28);
      color: rgba(255,255,255,0.95);
    }

    .leaderboard{
      margin-top: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      overflow: hidden;
    }
    .lbRow{
      display: grid;
      grid-template-columns: 44px 1fr 92px;
      gap: 10px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.05);
      border-top: 1px solid rgba(255,255,255,0.08);
      font: 700 13px system-ui, sans-serif;
      color: rgba(255,255,255,0.90);
    }
    .lbRow:first-child{ border-top: none; }
    .lbRow .rank{ opacity: 0.75; }
    .lbRow .name{ overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .lbRow .score{ text-align: right; font-weight: 900; }

    .help{
      margin-top: 12px;
      font: 600 12px system-ui, sans-serif;
      color: rgba(255,255,255,0.75);
      line-height: 1.4;
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="stage">
    <div class="frame">
      <canvas id="game" aria-label="Garlic Orbit Shooter"></canvas>

      <div class="topbar">
        <div class="pill" id="hudLeft">
          <span>üë§ <strong id="hudName">Player</strong></span>
          <span>‚Ä¢</span>
          <span>Best: <strong id="hudBest">0</strong></span>
          <span>‚Ä¢</span>
          <span>Last: <strong id="hudLast">0</strong></span>
        </div>

        <div class="pill" id="hudRight">
          <span>Score: <strong id="hudScore">0</strong></span>
          <span>‚Ä¢</span>
          <span>Lives: <strong id="hudLives">5</strong></span>
          <button class="btn" id="btnPause" title="Pause (P / Esc)">‚è∏ Pause</button>
          <button class="btn" id="btnMenu" title="Menu">‚ò∞ Menu</button>
        </div>
      </div>

      <!-- MENU OVERLAY -->
      <div class="overlay show" id="menuOverlay" role="dialog" aria-modal="true">
        <div class="panel">
          <div class="title">GARLIC ORBIT</div>
          <div class="sub" id="menuSubtitle">
            Shoot üßÑ to gain score. If you miss üßÑ you lose score. Avoid touching the red U!
          </div>

          <div class="tabs">
            <button class="tab active" id="tabMain">MAIN</button>
            <button class="tab" id="tabBoard">LEADERBOARD</button>
          </div>

          <div id="viewMain">
            <div class="grid">
              <div class="card">
                <div class="k">YOUR BEST</div>
                <div class="v" id="menuBest">0</div>
              </div>
              <div class="card">
                <div class="k">LAST SCORE</div>
                <div class="v" id="menuLast">0</div>
              </div>
            </div>

            <div class="field">
              <label for="nick">Nickname</label>
              <input id="nick" maxlength="18" placeholder="Enter nickname" />
            </div>

            <div class="row">
              <button class="btn primary" id="btnStart">‚ñ∂ Start</button>
              <button class="btn" id="btnResume">‚èµ Resume</button>
              <button class="btn" id="btnRestart">‚Üª Restart</button>
              <button class="btn danger" id="btnResetBoard">üóë Reset Leaderboard</button>
            </div>

            <div class="help">
              <div><b>Phone:</b> drag to move. <b>Hold the player</b> to auto-shoot.</div>
              <div><b>Computer:</b> move with A/D or ‚Üê/‚Üí. Auto-shoots while running. (Space also shoots.)</div>
              <div>Pause: button / <b>P</b> / <b>Esc</b>. Menu: button / <b>M</b>.</div>
            </div>
          </div>

          <div id="viewBoard" style="display:none;">
            <div class="leaderboard" id="lb"></div>
            <div class="row">
              <button class="btn" id="btnBack">‚Üê Back</button>
            </div>
            <div class="help">Top 10 saved locally on this device.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: true });

  // Storage keys
  const BEST_KEY = "garlic_orbit_best_v3";
  const LAST_KEY = "garlic_orbit_last_v3";
  const NAME_KEY = "garlic_orbit_name_v3";
  const BOARD_KEY = "garlic_orbit_board_v3";

  // UI elements
  const menuOverlay = document.getElementById("menuOverlay");
  const btnPause = document.getElementById("btnPause");
  const btnMenu  = document.getElementById("btnMenu");
  const btnStart = document.getElementById("btnStart");
  const btnResume= document.getElementById("btnResume");
  const btnRestart = document.getElementById("btnRestart");
  const btnResetBoard = document.getElementById("btnResetBoard");
  const nickInput = document.getElementById("nick");
  const menuBest = document.getElementById("menuBest");
  const menuLast = document.getElementById("menuLast");

  const tabMain = document.getElementById("tabMain");
  const tabBoard= document.getElementById("tabBoard");
  const viewMain= document.getElementById("viewMain");
  const viewBoard = document.getElementById("viewBoard");
  const lbWrap = document.getElementById("lb");
  const btnBack = document.getElementById("btnBack");

  const hudName = document.getElementById("hudName");
  const hudBest = document.getElementById("hudBest");
  const hudLast = document.getElementById("hudLast");
  const hudScore= document.getElementById("hudScore");
  const hudLives= document.getElementById("hudLives");

  const isCoarse = window.matchMedia("(pointer: coarse)").matches;
  const isSmall  = window.matchMedia("(max-width: 720px)").matches;
  const isPhoneLike = isCoarse || isSmall;

  const clamp = (v,a,b) => Math.max(a, Math.min(b,v));

  const game = {
    w: 0, h: 0,
    running: false,
    paused: false,
    over: false,
    inMenu: true,
    lastTime: 0,

    score: 0,
    best: 0,
    last: 0,
    lives: 5,

    spawnTimer: 0,
    spawnEvery: 650,

    enemyTimer: 0,
    enemyEvery: 2000, // U spawns every 2 seconds

    // U speed ramp: +10% every 2 seconds until player loses
    uSpeedMult: 1,
    uRampTimer: 0,
    uRampEvery: 2000,

    // U chase strength (px/s) will be multiplied by uSpeedMult
    uChaseSpeedBase: 180,

    shootTimer: 0,
    shootCooldown: 160, // ms

    difficultyTimer: 0,

    garlics: [],
    enemies: [],
    bullets: [],
    stars: [],

    // mobile hold-to-autofire
    holdFiring: false,

    input: {
      left: false, right: false,
      pointerDown: false,
      pointerX: 0,
      dragOffsetX: 0,
      dragging: false
    },

    name: "Player"
  };

  const player = {
    x: 0, y: 0,
    r: 22,
    speed: 520
  };

  // ===== Storage / leaderboard =====
  function loadName(){
    const n = (localStorage.getItem(NAME_KEY) || "").trim();
    game.name = n ? n.slice(0,18) : "Player";
    nickInput.value = game.name;
    hudName.textContent = game.name;
  }

  function saveName(){
    const n = (nickInput.value || "").trim().slice(0,18);
    game.name = n || "Player";
    localStorage.setItem(NAME_KEY, game.name);
    hudName.textContent = game.name;
  }

  function loadBestLast(){
    const b = Number(localStorage.getItem(BEST_KEY));
    const l = Number(localStorage.getItem(LAST_KEY));
    game.best = Number.isFinite(b) ? b : 0;
    game.last = Number.isFinite(l) ? l : 0;
    hudBest.textContent = String(game.best);
    hudLast.textContent = String(game.last);
    menuBest.textContent = String(game.best);
    menuLast.textContent = String(game.last);
  }

  function saveBestLast(){
    game.last = game.score;
    localStorage.setItem(LAST_KEY, String(game.last));

    if (game.score > game.best){
      game.best = game.score;
      localStorage.setItem(BEST_KEY, String(game.best));
    }
    loadBestLast();
  }

  function loadBoard(){
    try{
      const raw = localStorage.getItem(BOARD_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    } catch { return []; }
  }

  function saveBoard(arr){
    localStorage.setItem(BOARD_KEY, JSON.stringify(arr));
  }

  function submitToBoard(){
    const score = game.score;
    if (!Number.isFinite(score)) return;
    const entry = { name: game.name || "Player", score, t: Date.now() };
    const board = loadBoard();
    board.push(entry);
    board.sort((a,b) => b.score - a.score);
    saveBoard(board.slice(0,10));
  }

  function renderBoard(){
    const board = loadBoard();
    lbWrap.innerHTML = "";
    if (!board.length){
      const row = document.createElement("div");
      row.className = "lbRow";
      row.innerHTML = `<div class="rank">‚Äî</div><div class="name">No scores yet</div><div class="score">0</div>`;
      lbWrap.appendChild(row);
      return;
    }
    board.forEach((e,i) => {
      const row = document.createElement("div");
      row.className = "lbRow";
      row.innerHTML = `<div class="rank">#${i+1}</div><div class="name">${escapeHtml(e.name || "Player")}</div><div class="score">${Number(e.score)||0}</div>`;
      lbWrap.appendChild(row);
    });
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  // ===== HiDPI sizing =====
  function setupHiDPI(){
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;

    const ratio = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    canvas.width = Math.floor(cssW * ratio);
    canvas.height = Math.floor(cssH * ratio);

    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

    game.w = cssW;
    game.h = cssH;

    player.x = clamp(player.x || game.w/2, player.r + 10, game.w - player.r - 10);
    player.y = game.h - (isPhoneLike ? 98 : 82);
  }

  // ===== World =====
  function makeStars(n){
    game.stars = [];
    for (let i=0;i<n;i++){
      game.stars.push({
        x: Math.random()*game.w,
        y: Math.random()*game.h,
        r: Math.random()*1.8 + 0.3,
        v: Math.random()*22 + 8
      });
    }
  }

  function resetGame({keepMenu=false}={}){
    saveName();

    game.running = false;
    game.paused = false;
    game.over = false;
    game.lastTime = 0;

    game.score = 0;
    game.lives = 5;

    game.spawnTimer = 0;
    game.spawnEvery = 650;

    game.enemyTimer = 0;
    game.enemyEvery = 2000;

    // reset U ramp
    game.uSpeedMult = 1;
    game.uRampTimer = 0;
    game.uRampEvery = 2000;

    game.shootTimer = 0;
    game.difficultyTimer = 0;

    game.garlics = [];
    game.enemies = [];
    game.bullets = [];

    player.x = game.w/2;
    player.y = game.h - (isPhoneLike ? 98 : 82);

    const starCount = Math.floor(clamp((game.w*game.h)/23000, 70, 140));
    makeStars(starCount);

    if (!keepMenu) hideMenu();
    syncHUD();
    draw();
  }

  function startGame(){
    if (game.over) return;
    if (game.running) return;

    game.running = true;
    game.paused = false;
    game.inMenu = false;
    game.lastTime = 0;

    requestAnimationFrame(loop);
  }

  function gameOver(){
    game.over = true;
    game.running = false;
    game.paused = false;

    saveBestLast();
    submitToBoard();
    renderBoard();

    showMenu("GAME OVER");
  }

  function loseLife(){
    game.lives = Math.max(0, game.lives - 1);
    if (game.lives <= 0) gameOver();
  }

  function spawnGarlic(){
    const r = Math.random()*18 + 22;
    const x = Math.random()*(game.w - r*2) + r;
    const vy = Math.random()*90 + 120 + (game.score*0.25);
    const vx = (Math.random()-0.5)*90;
    game.garlics.push({ x, y: -r - 12, r, vy, vx });
  }

  function spawnEnemyU(){
    const w = Math.random()*24 + 58;
    const h = Math.random()*16 + 44;
    const x = Math.random()*(game.w - w) + w/2;

    // Fall speed starts like garlic, ramps by multiplier
    const baseVy = Math.random()*90 + 120;
    const vy = baseVy * game.uSpeedMult;

    // Start with small random vx; chase logic will override each frame
    const vx = (Math.random()-0.5)*30;

    game.enemies.push({ x, y: -h - 20, w, h, vy, vx });
  }

  function shoot(){
    const bx = player.x;
    const by = player.y - player.r - 10;
    game.bullets.push({ x: bx, y: by, r: 5, vy: 760 });
  }

  function circleRectHit(cx, cy, cr, rx, ry, rw, rh){
    const closestX = clamp(cx, rx, rx+rw);
    const closestY = clamp(cy, ry, ry+rh);
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) <= cr*cr;
  }

  function syncHUD(){
    hudScore.textContent = String(game.score);
    hudLives.textContent = String(game.lives);
    hudBest.textContent = String(game.best);
    hudLast.textContent = String(game.last);
    menuBest.textContent = String(game.best);
    menuLast.textContent = String(game.last);
    hudName.textContent = game.name;
  }

  function update(dt){
    // stars
    for (const s of game.stars){
      s.y += s.v*dt;
      if (s.y > game.h + 5){ s.y = -5; s.x = Math.random()*game.w; }
    }

    // player move (keyboard)
    let dir = 0;
    if (game.input.left) dir -= 1;
    if (game.input.right) dir += 1;
    if (dir !== 0) player.x += dir * player.speed * dt;

    // player move (drag)
    if (game.input.dragging){
      player.x = game.input.pointerX + game.input.dragOffsetX;
    }
    player.x = clamp(player.x, player.r + 10, game.w - player.r - 10);

    // spawn garlics
    game.spawnTimer += dt*1000;
    while (game.spawnTimer >= game.spawnEvery){
      game.spawnTimer -= game.spawnEvery;
      spawnGarlic();
    }

    // spawn U
    game.enemyTimer += dt*1000;
    while (game.enemyTimer >= game.enemyEvery){
      game.enemyTimer -= game.enemyEvery;
      spawnEnemyU();
    }

    // difficulty: garlic spawns faster over time
    game.difficultyTimer += dt*1000;
    if (game.difficultyTimer >= 1400){
      game.difficultyTimer = 0;
      game.spawnEvery = clamp(game.spawnEvery - 18, 240, 900);
    }

    // U speed ramps up: +10% every 2 seconds until player loses
    game.uRampTimer += dt*1000;
    while (game.uRampTimer >= game.uRampEvery){
      game.uRampTimer -= game.uRampEvery;
      game.uSpeedMult *= 1.1;
    }

    // auto shooting logic
    game.shootTimer += dt*1000;
    const desktopAuto = !isPhoneLike;
    const phoneAuto = isPhoneLike && game.holdFiring;

    if ((desktopAuto || phoneAuto) && game.shootTimer >= game.shootCooldown){
      game.shootTimer = 0;
      shoot();
    }

    // bullets
    for (let i=game.bullets.length-1;i>=0;i--){
      const b = game.bullets[i];
      b.y -= b.vy*dt;
      if (b.y < -50) game.bullets.splice(i,1);
    }

    // garlics
    for (let i=game.garlics.length-1;i>=0;i--){
      const g = game.garlics[i];
      g.y += g.vy*dt;
      g.x += g.vx*dt;

      if (g.x < g.r){ g.x = g.r; g.vx *= -1; }
      if (g.x > game.w - g.r){ g.x = game.w - g.r; g.vx *= -1; }

      // Missed garlic => -1 score
      if (g.y > game.h + g.r + 20){
        game.garlics.splice(i,1);
        game.score -= 1;
      }
    }

    // enemies (U) - chase player
    for (let i=game.enemies.length-1;i>=0;i--){
      const e = game.enemies[i];

      // Always chase player horizontally
      const chaseSpeed = (game.uChaseSpeedBase * game.uSpeedMult);
      const dx = player.x - e.x;
      const step = clamp(dx, -chaseSpeed*dt, chaseSpeed*dt);
      e.x += step;

      // Fall
      e.y += e.vy*dt;

      // Clamp inside screen (no bounce needed)
      const halfW = e.w/2;
      e.x = clamp(e.x, halfW, game.w - halfW);

      // U touches player => -1 life
      const rx = e.x - e.w/2;
      const ry = e.y - e.h/2;
      if (circleRectHit(player.x, player.y, player.r, rx, ry, e.w, e.h)) {
        game.enemies.splice(i, 1);
        loseLife();
        continue;
      }

      // Skipping U does nothing
      if (e.y > game.h + e.h + 30){
        game.enemies.splice(i,1);
      }
    }

    // collisions (bullets)
    for (let bi=game.bullets.length-1;bi>=0;bi--){
      const b = game.bullets[bi];

      // bullet hits U => bullet disappears, U is unaffected
      let hitU = false;
      for (let ei=game.enemies.length-1;ei>=0;ei--){
        const e = game.enemies[ei];
        const rx = e.x - e.w/2;
        const ry = e.y - e.h/2;
        if (circleRectHit(b.x, b.y, b.r, rx, ry, e.w, e.h)){
          game.bullets.splice(bi,1);
          hitU = true;
          break;
        }
      }
      if (hitU) continue;

      // garlic hit => +1 score
      for (let gi=game.garlics.length-1;gi>=0;gi--){
        const g = game.garlics[gi];
        const dx = b.x - g.x;
        const dy = b.y - g.y;
        const rr = (b.r + g.r) * (b.r + g.r);
        if ((dx*dx + dy*dy) <= rr){
          game.bullets.splice(bi,1);
          game.garlics.splice(gi,1);
          game.score += 1;
          break;
        }
      }
    }

    syncHUD();
  }

  // ===== Drawing =====
  function drawSpaceBg(){
    ctx.globalAlpha = 0.82;
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    for (const s of game.stars){
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    const grad = ctx.createRadialGradient(game.w*0.55, game.h*0.15, 10, game.w*0.55, game.h*0.15, game.w*0.85);
    grad.addColorStop(0, "rgba(120,160,255,0.12)");
    grad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,game.w,game.h);
  }

  function drawPlayer(){
    const x = player.x, y = player.y, r = player.r;

    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(80, 255, 150, 0.55)";
    ctx.beginPath();
    ctx.arc(x, y, r + 14, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = "rgba(40, 210, 110, 0.95)";
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.arc(x - 7, y - 7, 8, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.font = "900 26px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("$", x, y + 1);

    ctx.strokeStyle = "rgba(120,255,180,0.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y - r);
    ctx.lineTo(x, y - r - 18);
    ctx.stroke();
  }

  function drawGarlic(g){
    ctx.fillStyle = "rgba(255, 245, 235, 0.16)";
    ctx.beginPath();
    ctx.arc(g.x, g.y, g.r, 0, Math.PI*2);
    ctx.fill();

    ctx.font = `${Math.floor(g.r * 1.22)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";
    ctx.fillText("üßÑ", g.x, g.y + 1);
  }

  function drawEnemyU(e){
    const x = e.x, y = e.y, w = e.w, h = e.h;
    const left = x - w/2;
    const right = x + w/2;
    const top = y - h/2;
    const bottom = y + h/2;

    const stroke = Math.max(6, Math.floor(w * 0.14));
    const radius = Math.min(w, h) * 0.24;

    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.lineWidth = stroke + 10;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "rgba(255,70,70,0.55)";
    ctx.beginPath();
    ctx.moveTo(left + radius, top + stroke*0.2);
    ctx.lineTo(left + radius, bottom - radius);
    ctx.arcTo(left + radius, bottom, left + radius + radius, bottom, radius);
    ctx.lineTo(right - radius - radius, bottom);
    ctx.arcTo(right - radius, bottom, right - radius, bottom - radius, radius);
    ctx.lineTo(right - radius, top + stroke*0.2);
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.lineWidth = stroke;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "rgba(255, 40, 40, 0.95)";
    ctx.beginPath();
    ctx.moveTo(left + radius, top + stroke*0.2);
    ctx.lineTo(left + radius, bottom - radius);
    ctx.arcTo(left + radius, bottom, left + radius + radius, bottom, radius);
    ctx.lineTo(right - radius - radius, bottom);
    ctx.arcTo(right - radius, bottom, right - radius, bottom - radius, radius);
    ctx.lineTo(right - radius, top + stroke*0.2);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.font = `800 ${Math.floor(h*0.22)}px system-ui, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("U", x, y);
    ctx.restore();
  }

  function drawBullets(){
    for (const b of game.bullets){
      ctx.fillStyle = "rgba(140, 255, 190, 0.95)";
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "rgba(140, 255, 190, 0.16)";
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r + 6, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawPaused(){
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0,0,game.w,game.h);
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "900 42px system-ui, sans-serif";
    ctx.fillText("PAUSED", game.w/2, game.h/2 - 16);
    ctx.font = "700 16px system-ui, sans-serif";
    ctx.fillStyle = "rgba(255,255,255,0.82)";
    ctx.fillText("Press P / Esc or tap Pause to continue", game.w/2, game.h/2 + 26);
  }

  function draw(){
    ctx.clearRect(0,0,game.w,game.h);
    drawSpaceBg();
    drawBullets();
    for (const g of game.garlics) drawGarlic(g);
    for (const e of game.enemies) drawEnemyU(e);
    drawPlayer();
    if (game.paused && game.running) drawPaused();
  }

  function loop(t){
    if (!game.running) return;

    if (!game.lastTime) game.lastTime = t;
    let dt = Math.min(0.033, (t - game.lastTime) / 1000);
    game.lastTime = t;

    if (game.paused) dt = 0;
    else update(dt);

    draw();
    if (game.running) requestAnimationFrame(loop);
  }

  // ===== Menu / pause =====
  function showMenu(titleText){
    game.inMenu = true;
    menuOverlay.classList.add("show");
    document.querySelector(".title").textContent = titleText ? titleText : "GARLIC ORBIT";
    loadBestLast();
    renderBoard();
    syncHUD();
    updateMenuButtons();
  }

  function hideMenu(){
    game.inMenu = false;
    menuOverlay.classList.remove("show");
    updateMenuButtons();
  }

  function updateMenuButtons(){
    btnResume.style.display = (game.running && game.paused) ? "inline-flex" : "none";
  }

  function togglePause(){
    if (!game.running) return;
    game.paused = !game.paused;
    if (!game.paused){
      game.lastTime = 0;
      requestAnimationFrame(loop);
    } else draw();
    updateMenuButtons();
  }

  // ===== Input =====
  window.addEventListener("keydown", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") game.input.left = true;
    if (e.code === "ArrowRight" || e.code === "KeyD") game.input.right = true;

    if (e.code === "KeyP" || e.code === "Escape"){
      e.preventDefault();
      if (game.running) togglePause();
    }

    if (e.code === "KeyM"){
      e.preventDefault();
      showMenu();
      if (game.running && !game.paused) togglePause();
    }

    if (e.code === "Space"){
      e.preventDefault();
      if (!game.running && !game.over){
        hideMenu();
        startGame();
      } else if (game.running && !game.paused){
        if (game.shootTimer >= game.shootCooldown){
          game.shootTimer = 0;
          shoot();
        }
      } else if (game.running && game.paused){
        togglePause();
      }
    }

    if (e.code === "KeyR"){
      e.preventDefault();
      resetGame();
      hideMenu();
      startGame();
    }
  });

  window.addEventListener("keyup", (e) => {
    if (e.code === "ArrowLeft" || e.code === "KeyA") game.input.left = false;
    if (e.code === "ArrowRight" || e.code === "KeyD") game.input.right = false;
  });

  function getPointerPos(ev){
    const rect = canvas.getBoundingClientRect();
    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
  }

  canvas.addEventListener("pointerdown", (ev) => {
    canvas.setPointerCapture(ev.pointerId);
    game.input.pointerDown = true;

    if (menuOverlay.classList.contains("show")) return;

    const p = getPointerPos(ev);
    game.input.pointerX = p.x;

    if (!game.running && !game.over) startGame();

    if (game.running && game.paused){
      togglePause();
      return;
    }

    const dx = p.x - player.x;
    const dy = p.y - player.y;
    const nearPlayer = (Math.abs(dx) < 95 && Math.abs(dy) < 95);

    if (nearPlayer){
      game.input.dragging = true;
      game.input.dragOffsetX = player.x - p.x;
      if (isPhoneLike) game.holdFiring = true;
    } else {
      if (game.running && !game.paused && game.shootTimer >= game.shootCooldown){
        game.shootTimer = 0;
        shoot();
      }
    }
  });

  canvas.addEventListener("pointermove", (ev) => {
    if (!game.input.pointerDown) return;
    const p = getPointerPos(ev);
    game.input.pointerX = p.x;
  });

  function endPointer(){
    game.input.pointerDown = false;
    game.input.dragging = false;
    game.holdFiring = false;
  }

  canvas.addEventListener("pointerup", endPointer);
  canvas.addEventListener("pointercancel", endPointer);
  canvas.addEventListener("lostpointercapture", endPointer);

  // ===== Buttons =====
  btnPause.addEventListener("click", () => {
    if (!game.running) return;
    togglePause();
  });

  btnMenu.addEventListener("click", () => {
    showMenu();
    if (game.running && !game.paused) togglePause();
  });

  btnStart.addEventListener("click", () => {
    saveName();
    resetGame({keepMenu:true});
    hideMenu();
    startGame();
  });

  btnResume.addEventListener("click", () => {
    saveName();
    hideMenu();
    if (game.running && game.paused) togglePause();
  });

  btnRestart.addEventListener("click", () => {
    saveName();
    resetGame({keepMenu:true});
    hideMenu();
    startGame();
  });

  btnResetBoard.addEventListener("click", () => {
    localStorage.removeItem(BOARD_KEY);
    renderBoard();
  });

  nickInput.addEventListener("input", () => { saveName(); });

  tabMain.addEventListener("click", () => {
    tabMain.classList.add("active");
    tabBoard.classList.remove("active");
    viewMain.style.display = "";
    viewBoard.style.display = "none";
  });

  tabBoard.addEventListener("click", () => {
    tabBoard.classList.add("active");
    tabMain.classList.remove("active");
    viewMain.style.display = "none";
    viewBoard.style.display = "";
    renderBoard();
  });

  btnBack.addEventListener("click", () => { tabMain.click(); });

  // ===== Resize handling =====
  const ro = new ResizeObserver(() => {
    setupHiDPI();
    player.y = game.h - (isPhoneLike ? 98 : 82);
    draw();
  });
  ro.observe(canvas);

  // ===== Init =====
  loadName();
  loadBestLast();
  setupHiDPI();
  makeStars(Math.floor(clamp((game.w*game.h)/23000, 70, 140)));
  resetGame({keepMenu:true});
  renderBoard();
  showMenu();
})();
</script>
</body>
</html>
